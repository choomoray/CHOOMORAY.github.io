---
title: 51单片机入门学习
date: 2023-10-14 22:30:15
tag: [入门, 51]
categories: 学习
cover: https://i.postimg.cc/7ZqhpRq0/VCG41165531669.webp
---

## Vision5 & STC-ISP 的使用

### Vision5

Project → new vision project → 选存放位置 → 选择 AT89C52单片机 →  创建完毕 → 在Options for Target/Output 下点选上Create HEX_File，这样就可以编译后生成可烧录文件了

Target/Source Group 下右键，ADD NEW为新建一个文件，ADD Existing为添加文件目录下的其他文件

### STC-ISP

单片机型号选择 STC89C52RC/LE52RC，其他系统自动

----

## 技巧

```c

```

#### & | 或赋值

````c
TMOD &= 0xF0; 	// TMOD的第四位清零，高四位保持不变	1010 0011 & 1111 0000 = 1010 0000
TMOD |= 0x01;	// TMOD第一位置为1，高四位不变	1010 0011 | 0000 0001 = 1010 0001
````

|      |           运算           |               用法               |
| :--: | :----------------------: | :------------------------------: |
|  &   |   两数同为 1，结果为 1   | data&0x01：验证数据某一位是否为1 |
|  \|  | 两数有一个为 1，结果为 1 |  data\|0x01： 对数据某一位置为1  |
|  ~   |   两数为 异，结果为 1    |                                  |



----

## LED

**单片机 I/O 两种状态，1为高电平即5V，0为低电平0V**

### 点亮

使用十六进制数可直接控制8个LED灯的亮灭，也可使用2进制数控制单独一个等的状态：

```c
P2 = 0x01; // 0000 0001
P2_0 = 1;  // 0000 0001
```

### 跑马灯

按顺序逐一点亮LED，并通过延时程序可被观察到

```c
unsigned char LEDNUM = 0;
while(1){ // P2_0 -> P2_7
	LEDNUM++;
    if (LEDNUM >= 8){
        LEDNUM = 0;
    }
    /*
		这里让LED只亮一个完成跑马灯操作
		用LEDNUM来记录亮灯位置，通过位运算来实现跑马特效
		因为是定向移动，所以只需要判断LEDNUM是否达到临界值即可
		使用位操作来控制亮灯位置，又因为高低电平的缘故，需要对高电平操作	0000 1000
		最后对高电平操作的结果进行取反操作							 1111 0111
	*/
    P2 = ~(0x01 << LEDNUM);
}
while(1){ // P2_7 -> P2_0
	if (LEDNUM == 0){
		LEDNUM = 7;
	}else{
		LEDNUM--;
	}
    P2 = ~(0x01 << LEDNUM);
}
```

### 延时

不同频率芯片的延时各不相同

```c
void Delay_ms(unsigned int ms)		//@11.0592MHz
{
	unsigned char i, j;
	while(ms--){
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
	}
}
```



## 按键

按键使用方法和LED类似

### 按键抖动

按键拨片在按下和抬起瞬间难免发生抖动造成数据波动

可通过延时函数来消除这5~10ms的波动影响

```c
while(1){
    if (P3_1 == 0){
        Delay_ms(20);
        while(P3_1 == 0);
        Delay_ms(20);
        ...
    }
}
```

### 二进制计数

通过点按一个按键来实现二进制计数

```c
unsigned char NUM = 0;
while(1){
    if (P3_1 == 0){
        ... //消除按键抖动        
      	NUM++;
      	P2 = ~NUM;
    }
}
```

### 按键控制LED移位

通过按键实现LED的左右移动

其实就是跑马灯加上一个按键控制

```c
unsigned char LEDNUM = 0;
P2 = ~0x01;
while(1){		
    if (P3_0 == 0){
        Delay(20);
        while(P3_0 == 0);
        Delay(20);

        LEDNUM++;
        if (LEDNUM >= 8){
            LEDNUM = 0;
        }
        P2 = ~(0x01<<LEDNUM);
    }else if (P3_1 == 0){
        Delay(20);
        while(P3_1 == 0);
        Delay(20);			

        if (LEDNUM == 0){
            LEDNUM = 7;
        }else{
            LEDNUM--;
        }
        P2 = ~(0x01<<LEDNUM);
    }
}
```

## 数码管

数码管由74HC138译码器和动态数码管模块组成

数码管需要进行消影，在快速位选段选中上一个数据会窜到下一位数据里，形成重影

只需要加入一个极短的延时就可以解决





## 矩阵键盘





## 定时器



##### 

## 串口通信

#### 波特率计算器

在STC-IPS软件中有波特率计算功能，注意参数配置就好了，误差比较大的时候可以勾选 波特率倍速SMOD 来降低误差

|   系统频率   |     波特率     |   波特率倍速SMOD   |      误差      |
| :----------: | :------------: | :----------------: | :------------: |
|  11.0592MHz  |      4800      |     看情况勾选     |       ~        |
| **UART选择** | **UART数据位** |  **波特率发生器**  | **定时器时钟** |
|    串口1     |    8位数据     | 定时器1（8位重载） | 12T（FOSC/12） |

发送和接受设备需要保持相同的波特率才能正确的传输数据，还有应尽可能**不要将传输间隔小于误差值**，可通过短暂的延时函数解决！



## LED点阵屏



## 时钟 DS1302

[![image.png](https://i.postimg.cc/Kvqsf8sP/image.png)](https://postimg.cc/N5X4fBtF)



----

