# 确认项目内容





# 代码流程

## 延时函数

在**STC-ISP**软件的**延时计算器**内填入正确数据即可得到正确的延时函数

注意STC89C52单片机由于年代久远，指令集需要切换到STC-Y1系列

[![image.png](https://i.postimg.cc/tR1jYtFb/image.png)](https://postimg.cc/t7Hfc6rv)

```c
/**
  * @brief  延时函数
  * @param  需要延长的时间（单位ms）
  * @retval 无
  * unsigned char 0~255, 范围太小所以用unsigned int 0~65535
  */
void Delay(unsigned int ms)
{
	unsigned char i, j;
	while(ms--){	//@11.0592MHz	1ms
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
	}	
}
```

## 矩阵键盘（实现按键操作）

### 按键操作

需要8个按键：模式选择、方向↑↓←→、定闹钟、确认、取消

首先要检测按键是否被按下

矩阵键盘检测：先检测第一排S1-S4，然后根据第一排的数据检测对应列，分别+4、+8、+12，在检测按键过程中不要忘记了使用Delay函数消除抖动

[![image.png](https://i.postimg.cc/KzvyHcq7/image.png)](https://postimg.cc/zLMMLN13)

```c

/**
  * @brief  矩阵键盘读取按键键码
  * @param  无
  * @retval 返回按下按键的键值
  */
unsigned char MatrixKeyVolue()
{
	unsigned char KeyVolue = 0;
	
	P1 = 0x0f;
	if(P1 != 0x0f)	// 矩阵按键被按下
	{
		Delay(20);	// 延时消抖
		if(P1 != 0x0f)	// 矩阵按键被按下
		{
			P1 = 0x0f;		
			switch(P1)
			{
				case(0x07):KeyVolue = 0; break;
				case(0x0b):KeyVolue = 1; break;
				case(0x0d):KeyVolue = 2; break;
				case(0x0e):KeyVolue = 3; break;
			}
			P1 = 0xf0;		
			switch(P1)
			{
				case(0x70):KeyVolue = KeyVolue; break;
				case(0xb0):KeyVolue = KeyVolue + 4; break;
				case(0xd0):KeyVolue = KeyVolue + 8; break;
				case(0xe0):KeyVolue = KeyVolue + 12; break;
			}
			while(P1 != 0xf0)
			{
				Delay(20);
			}
		}
	}
	return KeyVolue;
}
```



## DS1302

DS1302是专门用来做时钟的芯片，CE=1时芯片开始工作，IO会在SCLK高低电平的变化中读取写入数据，SCLK的上升沿、下降沿是非常重要的，关乎着数据是否被正确读取写入

IO的数据流分为两段，前段为指令，后段为数据

[![image.png](https://i.postimg.cc/Kvqsf8sP/image.png)](https://postimg.cc/N5X4fBtF)

[![image.png](https://i.postimg.cc/j5JZyX1J/image.png)](https://postimg.cc/mzBYsQBb)

读地址为0x81（秒）, 0x83（分）, 0x85（时）, 0x87（日）, 0x89（月）, 0x8b（星期）, 0x8d（年）
写地址为0x80（秒）, 0x82（分）, 0x84（时）, 0x86（日）, 0x88（月）, 0x8a（星期）, 0x8c（年）

[![image.png](https://i.postimg.cc/CMCvcZz9/image.png)](https://postimg.cc/4ndbdxv1)

```c
/**
  * @brief  向DS1302写入数据
  * @param  Command	命令字
  * @param  Data	写入的数据
  * @retval 无
  */
void DS1302_WriteByte(unsigned char Command, Data)
{
	unsigned char i;
	DS1302_CE = 1;
	for(i = 0; i < 8; i++)
	{
		DS1302_IO = Command&(0x01<<i);
		DS1302_SCLK = 1;
		DS1302_SCLK = 0;
	}
	for(i = 0; i < 8; i++)
	{
		DS1302_IO = Data&(0x01<<i);
		DS1302_SCLK = 1;
		DS1302_SCLK = 0;
	}	
	DS1302_CE = 0;
}
```

```c
/**
  * @brief  DS1302读一个字节
  * @param  Command	指令
  * @retval 读出的数据
  */
unsigned char DS1302_ReadByte(unsigned char Command)
{
	unsigned char i, Data = 0x00;
	
	Command |= 0x01;	
	DS1302_CE = 1;
	for(i = 0; i < 8; i++)
	{
		DS1302_IO = Command&(0x01<<i);
		DS1302_SCLK = 0;
		DS1302_SCLK = 1;
	}
	for(i=0;i<8;i++)
	{
		DS1302_SCLK=1;
		DS1302_SCLK=0;
		if(DS1302_IO){Data|=(0x01<<i);}
	}
	
	DS1302_IO = 0;
	DS1302_CE = 0;
	return Data;
}
```

## 定时器

