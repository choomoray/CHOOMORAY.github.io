---
title: 51单片机STC82C52RC入门学习
date: 2024-4-4
tag:
  - 51
  - STC89C52RC
  - AT24C02
  - I2C
  - DS1302
  - 入门学习
categories: 
  - 51
top_img: false
cover: https://github.com/choomoray/choomoray.github.io/blob/image_backup/2023/51单片机STC89C52RC入门学习/封面.png?raw=true
---

# Keil & STC-ISP

## Keil uVision5 C51

`Keil uVision` 有很多版本，`STC89C51RC`单片机用的是C51版本

> **Project** → **new vision project** → 选存放位置 → 选择 **AT89C52**单片机 →  创建完毕 → 在**Options for Target/Output** 下点选上**Create HEX_File**，这样就可以编译后生成可烧录文件了

> **Target/Source Group** 下右键，**ADD NEW**为新建一个文件，**ADD Existing**为添加文件目录下的其他文件

## STC-ISP

> 单片机型号选择 **STC89C52RC/LE52RC**，其他系统自动    

----





# STC89C52单片机核心

![STC89C52单片机核心](https://github.com/choomoray/choomoray.github.io/blob/image_backup/2023/51%E5%8D%95%E7%89%87%E6%9C%BASTC89C52RC%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/51%20%E5%8D%95%E7%89%87%E6%9C%BA%E6%A0%B8%E5%BF%83.png?raw=true)

# LED

**单片机 I/O 两种状态，1为高电平即5V，0为低电平0V**



### 点亮LED

使用十六进制数可直接控制8个LED灯的亮灭，也可使用2进制数控制单独一个等的状态：

```c
P2 = 0x01; // 0000 0001
```



### 跑马灯

按顺序逐一点亮LED，并通过延时程序可被观察到

```c
unsigned char LEDNUM = 0;
while(1){ // P2_0 -> P2_7
	LEDNUM++;
    if (LEDNUM >= 8){
        LEDNUM = 0;
    }
    /*
		这里让LED只亮一个完成跑马灯操作
		用LEDNUM来记录亮灯位置，通过位运算来实现跑马特效
		因为是定向移动，所以只需要判断LEDNUM是否达到临界值即可
		使用位操作来控制亮灯位置，又因为高低电平的缘故，需要对高电平操作	0000 1000
		最后对高电平操作的结果进行取反操作							 1111 0111
	*/
    P2 = ~(0x01 << LEDNUM);
}
while(1){ // P2_7 -> P2_0
	if (LEDNUM == 0){
		LEDNUM = 7;
	}else{
		LEDNUM--;
	}
    P2 = ~(0x01 << LEDNUM);
}
```



### 延时 Delay

不同频率芯片的延时各不相同

![Delay延时计算器](https://img2.imgtp.com/2024/03/21/wccORVdM.png)

```c
void Delay1ms()		//@12.000MHz
{
	unsigned char i, j;

	i = 2;
	j = 239;
	do
	{
		while (--j);
	} while (--i);
}
```



# 按键

按键使用方法和LED类似

### 按键抖动

按键拨片在按下和抬起瞬间难免发生抖动造成数据波动

可通过延时函数来消除这5~10ms的波动影响

```c
while(1){
    if (P3_1 == 0){
        Delay_ms(20);
        while(P3_1 == 0);
        Delay_ms(20);
        ...
    }
}
```

### 二进制计数

通过点按一个按键来实现二进制计数

```c
unsigned char NUM = 0;
while(1){
    if (P3_1 == 0){
        ... //消除按键抖动        
      	NUM++;
      	P2 = ~NUM;
    }
}
```

### 按键控制LED移位

通过按键实现LED的左右移动

其实就是跑马灯加上一个按键控制

```c
unsigned char LEDNUM = 0;
P2 = ~0x01;
while(1){		
    if (P3_0 == 0){
        Delay(20);
        while(P3_0 == 0);
        Delay(20);

        LEDNUM++;
        if (LEDNUM >= 8){
            LEDNUM = 0;
        }
        P2 = ~(0x01<<LEDNUM);
    }else if (P3_1 == 0){
        Delay(20);
        while(P3_1 == 0);
        Delay(20);			

        if (LEDNUM == 0){
            LEDNUM = 7;
        }else{
            LEDNUM--;
        }
        P2 = ~(0x01<<LEDNUM);
    }
}
```

# 数码管

数码管由74HC138译码器和动态数码管模块组成

数码管需要进行消影，在快速位选段选中上一个数据会窜到下一位数据里，形成重影

只需要加入一个极短的延时就可以解决





# 矩阵键盘





# 定时器



##### 

# 串口通信

#### 波特率计算器

在STC-IPS软件中有波特率计算功能，注意参数配置就好了，误差比较大的时候可以勾选 波特率倍速SMOD 来降低误差

|   系统频率   |     波特率     |   波特率倍速SMOD   |      误差      |
| :----------: | :------------: | :----------------: | :------------: |
|  11.0592MHz  |      4800      |     看情况勾选     |       ~        |
| **UART选择** | **UART数据位** |  **波特率发生器**  | **定时器时钟** |
|    串口1     |    8位数据     | 定时器1（8位重载） | 12T（FOSC/12） |

发送和接受设备需要保持相同的波特率才能正确的传输数据，还有应尽可能**不要将传输间隔小于误差值**，可通过短暂的延时函数解决！



# LED点阵屏



# 时钟 DS1302

![DS1302工作原理](https://img2.imgtp.com/2024/03/21/wccORVdM.png)







# I2C总线





# AT24C02

> AT24C02掉电不丢失存储器







----

# 运算法则

|          |       | 运算                             | 用法                             |
| :------: | :---: | :------------------------------- | :------------------------------- |
|  **与**  |   &   | 同为1，结果为 1，任意0，结果为0  | data&0x01：验证数据某一位是否为1 |
|  **或**  |  \|   | 同为0，结果为0，任意 1，结果为 1 | data\|0x01： 对数据某一位置为1   |
|  **非**  |   !   | !1=0；!0=1                       |                                  |
| **异或** |   ^   | 不同为1，相同为0                 |                                  |
| **同或** | **⊙** | 相同为1，不同为0                 |                                  |

Tips：在程序中，一般没有**同或运算符：可以用两个数的异或结果再次异或1**，即可得到两个数的同或结果。

1010 ^ 1110 = 0100 ^ 1111 = 1011



# 常用方法

使用`与、或、非`运算可以很大程度上简化代码



## 清零

> 两数同为1，&的结果才为1，因此**任何一个数`&`0结果为0**
>
> 1011 1100 & 0000 0000 = 0000 0000



## 置一

> 两数中有1，|的结果便为1，因此可以
>
> 0000 0000 | 0000 0001 = 0000 0001



# 扩展用法

在不同场景中根据场景需求可以灵活变通使用



## TMOD参数设置

> `&`：**低四位清零**，高四位保持不变
>
> 1010 0011 & 1111 0000 = 1010 0000

> `|`：**第一位置为1**，高四位不变
>
> 1010 0011 | 0000 0001 = 1010 0001

----





<details> <summary>Title</summary> contents ... </details>



{% note default flat %}
default 提示块标签
{% endnote %}

{% hideInline 你好,display,bg,color %}



