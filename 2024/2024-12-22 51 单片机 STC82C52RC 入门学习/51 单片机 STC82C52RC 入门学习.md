---

title: 51单片机STC82C52RC入门学习
date: 2024-12-22
tag:
  - C51
  - STC89C52RC
categories: 
  - 学习
---



# 原理图集

{%tabs 单片机原理图%}

<!--tab STC89C52单片机核心-->

![STC89C52单片机核心](https://img2.imgtp.com/2024/05/27/ayxjQQZt.png)

<!--endtab--> <!--tab LED-->

![LED](https://img2.imgtp.com/2024/05/27/vucwMJGY.png)

<!--endtab--> <!--tab 独立按键-->

![独立按键](https://img2.imgtp.com/2024/05/27/ItJj9arF.png)

<!--endtab--> <!--tab 矩阵按键-->

![矩阵按键](https://img2.imgtp.com/2024/05/27/7p3bvlge.png)

<!--endtab--> <!--tab DS18B20-->

![DS18B20](https://img2.imgtp.com/2024/05/27/WL6Wpl4d.png)

<!--endtab--> <!--tab 蜂鸣器-->

![蜂鸣器](https://img2.imgtp.com/2024/05/27/vq1kJQEj.png)

<!--endtab--> <!--tab 红外接收器-->

![红外接收器](https://img2.imgtp.com/2024/05/27/lY2t4x1O.png)

<!--endtab--> <!--tab DS1302时钟-->

![DS1302时钟](https://img2.imgtp.com/2024/05/27/kVQxqej6.png)

<!--endtab--> <!--tab 74HC138译码器-->

![74HC138译码器](https://img2.imgtp.com/2024/05/27/xx3n8UcH.png)

<!--endtab--> <!--tab 74HC595(串转并)-->

![74HC595（串转并）](https://img2.imgtp.com/2024/05/27/tfJU3RG4.png)

<!--endtab--> <!--tab LCD1602接口-->

![LCD1602接口](https://img2.imgtp.com/2024/05/27/1u1ryCMP.png)

<!--endtab--> <!--tab LCD12864-->

![LCD12864](https://img2.imgtp.com/2024/05/27/Oqef8hV3.png)

<!--endtab--> <!--tab 8*8LED点阵-->

![8*8LED点阵](https://img2.imgtp.com/2024/05/27/606HKZJS.png)

<!--endtab--> <!--tab 动态数码管-->

![动态数码管](https://img2.imgtp.com/2024/05/27/x1GirABt.png)

<!--endtab--> <!--tab ADC-->

![ADC](https://img2.imgtp.com/2024/05/27/fzv3gik7.png)

<!--endtab--> <!--tab DAC(PWM)-->

<img src="https://img2.imgtp.com/2024/05/27/Pcsj0Owf.png" alt="DAC（PWM）" style="zoom:80%;" />

<!--endtab--> <!--tab EEPROM-->

![EEPROM](https://img2.imgtp.com/2024/05/27/tYyiCmWM.png)

<!--endtab--> <!--tab USB转TTL下载-->

![USB转TTL下载](https://img2.imgtp.com/2024/05/27/0p0dt2kH.png)

<!--endtab--> <!--tab DC5V电源-->

![DC5V电源](https://img2.imgtp.com/2024/05/27/JSuJ4kPb.png)

<!--endtab--> <!--tab NRF24L01接口-->

![NRF24L01接口](https://img2.imgtp.com/2024/05/27/di7Ili9e.png)

<!--endtab--> <!--tab 五线四项步进电机-->

![五线四项步进电机](https://img2.imgtp.com/2024/05/27/4sqEwmI8.png)

<!--endtab-->

{%endtabs%}





# LED

{%note no-icon%}**发光二极管**（**Light Emitting Diode**）{%endnote%}



## 点灯

{%tabs Keil & STC%} <!--tab Keil C51-->

<img src="https://img2.imgtp.com/2024/05/27/Uab3hpg6.png" style="zoom:50%;" />

{%note no-icon%}**`Keil uVision` 有很多版本，`STC89C51RC`单片机用的是C51版本**{%endnote%}

使用Keil编写程序：

**Project** → **new vision project** → 选存放位置 → 选择 **AT89C52**单片机 →  创建完毕 → 在**Options for Target的Output选项卡**下点选上**Create HEX_File**，这样就可以编译后生成可烧录文件了

**Target/Source Group** 下右键，**ADD NEW**为新建一个文件，**ADD Existing**为添加文件目录下的其他文件



{%tabs 点亮LED灯珠%}

<!--tab 原理-->

工欲善其事必先利其器，在写代码之前需要看懂原理图：

<img src="https://img2.imgtp.com/2024/05/27/vucwMJGY.png" style="zoom:50%;" />

8个LED灯珠并联在一个VCC电源上，又分别串联一个电阻连接到单片机P2_0~P2_7接口上，想要让LED灯珠亮起，必须让两侧产生电压差，因此控制单片机P2接口让其为**低电平**即可点亮灯珠。

现在我们要让第三个LED亮起，有下面几种方法：

1. 单独控制第三个LED灯的接口**P2_2 = 0**
2. 控制P2整组接口使**P2 = 0xfb**（1111 1011）

<!--endtab--> <!--tab 实现-->

```c
#include <REGX52.H>

void main(){
    P2 = 0xfb;	// 1111 1011
    while(1){

    }
}
```

<!--endtab-->

{%endtabs%}

<!--endtab--> <!--tab STC-ISP-->

![](https://img2.imgtp.com/2024/05/27/wqprMZMI.png)

单片机型号选择 **`STC89C52RC/LE52RC`**，其他系统默认，选择好程序文件点击下载/编程，重启单片机即可完成烧录

<!--endtab--> 

{%endtabs%}



## 闪烁

### 延时函数 Delay()

{%note no-icon%}循环控制LED的亮灭实现LED的闪烁，使用`STC-ISP`能够生成需要的延时函数：{%endnote%}

{%tabs Delay%} <!-- tab Delay延时函数 -->

```c
/*
 * @brief	以毫秒为单位的延时函数 @11.0592MHz
 * @param	xms	延时时间
 * @retval	无
 */
void Delay(unsigned int xms)
{
	unsigned char i, j;
	
	while(xms--){
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
	}	
}
```



<!--endtab--> <!-- tab 在STC-ISP中生成-->

![Delay延时函数](https://img2.imgtp.com/2024/05/27/ChDiJHnS.png)

在右上角部分找到**软件延时计算器**：

`系统频率`：单片机晶振上标有

`定时长度`：自定

`指令集`：选择包含自己用的单片机指令集即可

<!--endtab--><!--tab 闪烁实现-->

```c
#include <REGX52.H>
#include <INTRINS.H>

void Delay(unsigned int xms)		//@11.0592MHz 1ms
{
	unsigned char i, j;
	
	while(xms--){
		_nop_();
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
	}	
}

void main(){	
	while(1){
		P2 = 0xff;
		Delay(500);
		P2 = ~0xff;		
		Delay(500);
	}	
}
```

<!--endtab--> {%endtabs%}





## 跑马灯

{%tabs 跑马灯%}

<!--tab 原理-->

{%note default disabled%}**按顺序逐一点亮LED，并通过延时程序让其可被观察到**{%endnote%}

最简单的方法就是控制一个灯一个灯的点亮

进阶操作应该去使用C语言的特性去实现，也就是位操作：

前面说到：让P2口置0LED才会亮起，所以我们先假设让0x01亮第一个灯，只要保证0x01左移就可以让灯跑起来：

{%note no-icon%}0000 000<font color=red>1</font>

0000 00<font color=red>1</font>0

0000 0<font color=red>1</font>00 ...{%endnote%}

所以我们需要一个值来记录灯的位置，当灯到达边缘需要即时让灯重置位置。



{%note primary disabled%}<font color=purple>进阶操作：另外加一个灯，让它跟在第一个灯后面</font>

{%endnote%}

这里使用到了`与或非`的知识：

{%note no-icon%}

与 &：同为1结果为1

或 |：任意为1结果为1

非 ~：结果相反

{%endnote%}

还是很简单的，用另一个变量记录上一个变量的值就可以了，最后在赋值时将两个变量进行求或操作：

{% note success disabled%}P2 = ~((0x01 << num) | (0x01 << tmp));{%endnote%}

{% note info disabled%}与或运算不使用`||`，使用`|`，多么痛的领悟{%endnote%}

<!--endtab--> <!--tab 实现-->

```c
unsigned char num = 0;	// 记录亮灯的位置
P2 = ~0x01;
while(1){
    if (++num > 8){	// 如果灯到达边缘，重置位置
        num = 0;
    }
    P2 = ~(0x01 << num);
    Delay(200);
}
```

```c
if (++num > 8){
    num = 0;
    tmp = 8;
}
P2 = ~((0x01 << num) | (0x01 << tmp));
tmp = num;
```

<!--endtab--> {%endtabs%}





# 独立按键

## 按键点灯

{%tabs 按键点灯%}

<!--tab 原理-->

![独立按键](https://img2.imgtp.com/2024/05/27/ItJj9arF.png)

四个独立按键并联在GND，又分别与P3寄存器串联，当按键按下时，P3接地为低电平，因此检测按键是否按下只需要看P3_0 - P3_3 是否为0

<!--endtab--> <!-- tab 实现-->

```c
void main(){
	P2_0 = 1;
	while(1){
		if (P3_1 == 0){
			P2_0 = 0;
		}else{
			P2_0 = 1;
		}
	}
}
```

<!--endtab-->

{%endtabs%}

## 按键消抖

{%tabs 按键消抖%}

<!--tab 原理-->

<img src="https://img2.imgtp.com/2024/05/27/oJ4OV2N7.png" style="zoom:67%;" />



{%note no-icon%}**按键消抖是防止按键输入被CPU误读多次的必要手段**{%endnote%}

按键所用开关为机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，在闭合及断开的瞬间均伴随有一连串的抖动（大约5-10ms），为了不产生这种现象而作的措施就是按键消抖

按键消抖一般使用Delay延时函数覆盖整个按下抖动过程，也就是在检测到按键按下后等待20ms再次检测直到抬起，然后进入抬起消抖的20ms

<!--endtab--> <!-- tab 实现-->

```c
while(1){
    if (P3_1 == 0){
        Delay(20);
        while(P3_1 == 0);
        Delay(20);
        ...
    }
}
```

<!--endtab--> {%endtabs%}



## 按键控制LED移位

{%tabs 按键控制LED移位%} <!--tab 原理-->

按键控制LED位移主要用位操作实现，注意边界即可

<!--endtab--> <!--tab 实现-->

```c
void main(){
	char location = 0;
	P2 = 0xfe;
	while(1){
		if(P3_1 == 0){
			Delay(20);
			while(P3_1 == 0);
			Delay(20);
            
			if (--location < 0){
				location = 7;
			}	
			P2 = ~(0x01 << location);			
		}
		if(P3_0 == 0){
			Delay(20);
			while(P3_0 == 0);
			Delay(20);
            
			if (++location > 7){
				location = 0;
			}
			P2 = ~(0x01 << location);			
		}
	}
}
```

<!--endtab--> {%endtabs%}





# 数码管

## 点亮数码管

{%tabs 点亮数码管%} <!--tab 原理-->

{%note no-icon%}数码管的原理还是挺复杂的，用到的器件除了两个数码管之外，还加了两个芯片：

`74HC245驱动增强`和`74HC138译码器`{%endnote%}



先从两个数码管说起，八个COM子单元共阴极的一端并联在74HC138译码器上，由74HC138译码器连接到P2寄存器2、3、4端口，另一端分别并联后串联一个电阻接到74HC245上，然后由74HC245连接到P0寄存器。74HC245的作用：单片机输出的电流非常小，通过中继一个带电源的中间设备，将单片机由能量提供设备变成信号输出设备，使得数码管更亮。

![](https://img2.imgtp.com/2024/05/27/x1GirABt.png)

{%note no-icon%}现在我们要让LED6点亮，并让其值为6，需要走以下两步：

1. 通过74HC245让数码管显示6
2. 通过74HC138译码器选择LED6显示 {%endnote%}

{%note success no-icon%}第一步：数码管显示6需要点亮a c d e f 六个数码管，分别对应B0 B2 B3 B4 B5 B6 → A0 A2 A3 A4 A5 A6，即P0 = 0111 1101 = 0x7D（P0写法正好相反，是从高位到低位）{%endnote%}

<img src="https://img2.imgtp.com/2024/05/27/xx3n8UcH.png" style="zoom:40%;" />

{%note no-icon%}根据P2寄存器的三个端口，按二进制的形式转化为低电平的Y0 - Y7{%endnote%}

{%note success no-icon%}第二步：让LED6亮起，需要P2_2 P2_3 P2_4（最低位） = Y5 = 101，即P2 = 0001 0100 = 0x14{%endnote%}

<!--endtab--> <!--tab 实现-->

```c
void main(){
	while(1){
		P2 = 0x14;
		P0 = 0x7D;
	}
}
```

<!--endtab-->{%endtabs%}

## 动态数码管显示

{%tabs 动态数码管显示%} <!--tab 原理-->

实现多个数码管同时显示，理论上是不可能实现的，因为COM子单元在同一时间收到的信号是一样的，也就是在同一时间，数码管能且只能显示一个，但是通过**视觉暂留**可以让人有多个数码管在同时显示的错觉。

### 数码管消影

{%note no-icon%}数码管在快速位选段选中上一个数据会窜到下一位数据里，形成重影,只需要加入一个极短的延时（1ms）就可以解决，重置P0 = 0x00可解决重影问题。

{%endnote%}



<!--endtab-->   <!--tab 实现-->

{%tabs 数码管消影%}

<!--tab 关键代码-->

```c
//数码管段码表
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
```

```c
/*
 * @brief   数码管显示
 * @param   Location    显示位置
 * @param   Number  	显示数字
 * @retval  无
 */
void Nixie(unsigned char Location, Number)
{
	switch(Location)		//位码输出
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];	//段码输出
	Delay(1);
	P0 = 0x00;
}
```

<!--endtab-->  <!--tab 实现-->

```c
void main()
{	
	while(1)
	{
		Nixie(1,1);
		Nixie(2,2);
		Nixie(3,3);
	}
}
```

 <!--endtab--> {%endtabs%}  <!--endtab--> {%endtabs%}









# 矩阵键盘

## 检测矩阵键盘

{%tabs 检测矩阵键盘%} <!--tab 原理 -->

<img src="https://img2.imgtp.com/2024/05/27/7p3bvlge.png" style="zoom: 67%;" />

矩阵按键和独立按键相似，区别在于把独立按键的共阴极拆分成4个，原理也类似：检测时单独拿出一行或一列，比如P1_7，把P1_7置低电平（P1_4 P1_5 P1_6）检测P1_0 P1_1 P1_2 P1_3四个高电平谁变低电平谁就是被按下的按键。

<!--endtab--> <!--tab 实现-->

```c
/**
  * @brief  检测矩阵按键是否被按下
  * @param  无
  * @retval 按下的值
  */
unsigned char KeyDown(){
    unsigned char KeyValue=0;
	
	P1=0xFF;
	P1_3=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyValue=1;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyValue=5;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyValue=9;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyValue=13;}
	
	P1=0xFF;
	P1_2=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyValue=2;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyValue=6;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyValue=10;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyValue=14;}
	
	P1=0xFF;
	P1_1=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyValue=3;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyValue=7;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyValue=11;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyValue=15;}
	
	P1=0xFF;
	P1_0=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);KeyValue=4;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);KeyValue=8;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);KeyValue=12;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);KeyValue=16;}
	
	return KeyValue;
}
```

<!--endtab--> {%endtabs%}



# LED点阵屏





# 定时器/计数器

{%tabs 定时器/计数器%}<!--tab 原理-->



单片机内部设置两个16位定时器/计数器，其核心部件是一个加法计数器，本质是对脉冲进行计数：如果计数脉冲来自系统时钟，则为定时方式，此时定时器每12个时钟或6个时钟得到一个计数脉冲，计数值加一；如果脉冲来自单片机外部引脚，则为计数方式，每来一个脉冲加一。

定时器寄存器由四部分组成：可位寻址TCON、不可位寻址TMOD、TL和TH：

![](https://img2.imgtp.com/2024/05/27/uA5XMXbq.png)

{%tabs 定时器位%} <!--tab TCON-->

控制寄存器

**TF**：溢出中断标志位，当T0从初值开始加一计数到产生溢出时，由硬件使TF0置1，直到CPU响应中断由硬件复位

**TR**：控制定时器运行，TR = 1开始计数

<!--endtab--> <!--tab TMOD-->

模式寄存器

GATE：0：只需要软件就可以控制打开寄存器（常用）；1：需要INT1脚为高，TR1控制位置1才可以打开。

C/T：0：定时器；1：计数器。

M1 & M2：模式选择：00：13位寄存器；01：16位寄存器（常用）；10：8位自动重装载寄存器；11：停止工作。

{%note info disabled%}不可位寻址，赋值需要整体赋值，但TMOD又同时控制两个寄存器，所以在赋值时也有技巧，通过位操作可以实现高四位不变第四位赋值的操作：

TMOD &= 0xF0;

TMOD |= 0x01;

{%endnote%}

<!--endtab--> <!--tab TL & TH-->

{%note no-icon%}**TH & TL**

![](https://img2.imgtp.com/2024/05/27/XfY4tICX.png)

如下图：TH&TL分别能存储8位共计一个周期计数66536个，当存满后溢出1到TF，然后进入下一周期，我们要做的就是通过程序记录TF然后将它置0循环往复，以此达到定时的效果。

一个周期65536us=65ms，可以设置TH&TL的初值，让初值和65536的差值正好是我们需要的时间来设置定时时间。

{%endnote%}

<!--endtab-->  <!--tab 中断-->

定时器部分完成，下面是简单了解的中断部分：

{%note no-icon%}我们需要打开系统总中断允许和定时器中断下允许：**EA** & **ET**，也需要设置中断次序**PT**（系统默认最低打断优先级）{%endnote%}

![](https://img2.imgtp.com/2024/05/27/g1ZARQl3.png)

![](https://img2.imgtp.com/2024/05/27/rW4jm9rp.png)

{%note no-icon%} {%endnote%}

<!--endtab-->  {%endtabs%}

<!--endtab--> <!--tab 用法-->

当时是选择自动生成！

<img src="https://img2.imgtp.com/2024/05/27/16xyNVyG.png" style="zoom:100%;" />

<!--endtab--> <!--tab 实现-->

```c
/*
 * @brief	定时器0中断初始化
 * @param	无
 * @retval	无
 */
void Timer0Init(void)		//1毫秒@11.0592MHz
{
	// AUXR &= 0x7F;		//定时器时钟12T模式
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0x66;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
    
    ET0 = 1;		//打开定时器中断
    EA = 1;			//打开系统中断
    
    PT0=0;			//设置定时器中断优先级    
}
```

```c
void main(){	
    Timer0Init();
	while(1);
}

void Timer0_Routine() interrupt 1{
	static unsigned int timer0Count = 0;
	TL0 = 0x66;
    TH0 = 0xfc;
	if (++timer0Count >= 1000){		
		timer0Count = 0;
		P2_0 = ~P2_0;
	}
}
```

<!--endtab--> {%endtabs%}





# 串口通信





## 波特率计算器

在STC-IPS软件中有波特率计算功能，注意参数配置就好了，误差比较大的时候可以勾选 波特率倍速SMOD 来降低误差

|   系统频率   |     波特率     |   波特率倍速SMOD   |      误差      |
| :----------: | :------------: | :----------------: | :------------: |
|  11.0592MHz  |      4800      |     看情况勾选     |       ~        |
| **UART选择** | **UART数据位** |  **波特率发生器**  | **定时器时钟** |
|    串口1     |    8位数据     | 定时器1（8位重载） | 12T（FOSC/12） |

发送和接受设备需要保持相同的波特率才能正确的传输数据，还有应尽可能**不要将传输间隔小于误差值**，可通过短暂的延时函数解决！



# I2C

{%tabs I2C%}



{%endtabs%}
